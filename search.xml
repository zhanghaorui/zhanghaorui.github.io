<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Chapter01]]></title>
    <url>%2F2019%2F08%2F18%2FChapter01_%E6%95%B0%E7%BB%84%E3%80%81%E9%9B%86%E5%90%88%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[第一章 Array 数组 什么是数组 数组，就是把有限个数据类型一样的元素按顺序存放在一起，用一个变量命名，然后通过编号可以按访问顺序访问指定位置的元素的一个有序集合。 简单来说，就是为了方便把这些元素放在一起，用一个变量命名，然后通过编号去获取每个元素，这个编号叫做下标或者(索引)，一般都是从0开始。 多维数组可以看成多个一维数组。 数组的存储结构 我们在定义数组时，要先确定一个值，也就是数组的长度;然后，系统会根据我们声明的数据类型开辟一些空间。这时，这些空间就归这个变量所有了 所以有以下情况 只声明了指定长度的空间，没有初始化值 声明了指定长度的空间，初始化了部分值 声明了指定空间的长度，初始化了全部的值 数组的特点 定长 数组的长度是固定的，一旦定义之后是不能改变的，如果想要继续存放数据的话，只能重新声明一个新的数组了。 按顺序访问 我们在访问一个数组中的某个元素时，必须从第一个元素开始按顺序访问，直到访问到指定位置的元素。 集合 什么是集合 在这里讲的集合主要是可变长度的列表。 集合的实现 我们以Java.util包下的ArrayList为例 ArrayList可以理解为数组的扩展，或者是可变长度的数组 它的实现过程如下图所示(图略) 在添加元素的时候判断内部数组的长度是否足够 如果不够，创建新的数组，将老数组元素复制到新数组中 若长度足够的话，则直接添加元素到数组里 用数组实现集合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238 package com.imooc.learn.AlgorithmLearning.Chapter01; import java.util.Arrays; public class ArrayList &#123; private static final int INITIAL_SIZE = 10; private int size = 0; private int[] arr; public ArrayList()&#123; arr = new int[INITIAL_SIZE]; &#125; public ArrayList(int initial)&#123; if (initial&lt;0)&#123; initial = INITIAL_SIZE; &#125; arr = new int[initial]; &#125; /* * 添加元素 * add elements * */ public void add(int num)&#123; if (size==arr.length)&#123; arr = Arrays.copyOf(arr,size*2); &#125; arr[size++] = num; &#125; /* * 获取元素 * get elements * */ public int get(int i)&#123; if (i&gt;=size)&#123; throw new IndexOutOfBoundsException(&quot;大兄弟 数组越界了&quot;); &#125; return arr[i]; &#125; /* * 设置指定位置的元素值 * set elements in order * */ public int set(int i,int num)&#123; int oldNum = get(i); arr[i] = num; return oldNum; &#125; /* * 获取变长数组的长度 * get arr.length * */ public int size()&#123; return size; &#125; &#125; 3. 集合的特点 1. 集合的特点，就是变长，变长是相对而言的 2. 在正常情况下会有两个系统开销，一个是数组总是比我们实际使用的数组长度长，所以存在空间浪费;另一个是当数组不够长时，需要新建一个更长的数组，同时把旧数组的数据复制到新数组中，这个操作会比较消耗系统的性能。 4. 数组与变长数组的性能分析 * 在数组中增删改的时间复杂度都是O(n)--- * 散列表 1. 什么是散列表 * 散列表，又叫哈希表，是通过给定的关键字的值直接访问到具体对应的值的一个数据结构。也就是说，把关键字映射到一个表中的位置来直接访问记录，以加快访问速度。 * 通常 我们把这个关键字称为key，把这个对应记录称为Value 也就是说通过key访问一个映射表来得到Value的地址，而这个映射表，也称为散列函数或者哈希函数，存放记录的数组叫做散列表。 * 通过某个key一定会得到唯一的Value地址 * 简单介绍几种哈希函数: 1. 直接寻址法 * 取关键字或者关键字的某个线性函数值为散列地址 2. 数字分析法 * 通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如:学号——前面的部分差别不太大，所以用后面的部分来构造散列地址。 3. 平方取中法 * 当无法确定关键字里哪几位分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为:计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。 4. 取随机数法 * 使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。 5. 除留取余法 * 取关键字被某个不大于散列表的表长n的数m除后所得的余数p为散列地址。这种方式也可以在用过其他方法后再使用。该函数对m的选择很重要，一般取素数或者直接用n。 2. 对散列表函数产生冲突的解决办法 1. 开放地址法 * 当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时，对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址，如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。 2. 再哈希法 * 在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。缺点是:增加了时间。 3. 链地址法 * 对key通过哈希之后落在同一个地址上的值，做一个链表。 4. 建立一个公共溢出区 * 建立公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。 3. 散列表的特点 * 散列表有两种用法: 1. key和value值一样: set 2. key和value值不同: map * 特点 1. 访问速度很快 2. 需要额外的空间 3. 无序 4. 可能会产生碰撞 4. HashTable的实现````Javapublic class HashTable &#123; /*默认散列表的初始化长度 * 设置小一些，我们能清楚的看到扩容 * 在实际使用中可以在初始化时传参 * */ private static final int DEFAULT_INITIAL_CAPACITY = 4; /* * 扩容因子 * */ private static final float LOAD_FACTOR = 0.75f; /* * 散列表数组 * */ private Entry[] table = new Entry[DEFAULT_INITIAL_CAPACITY]; private int size = 10; private int use = 10; /* * 添加/修改 * */ public void put(int key,int value)&#123; int index = hash(key); if (table[index]==null)&#123; table[index] = new Entry(-1,-1,null); &#125; Entry e = table[index]; if (e.next==null)&#123;// 不存在值，向链表添加，有可能扩容，要用table属性 table[index].next = new Entry(key,value,null); size++; use++; if (use&gt;=table.length*LOAD_FACTOR)&#123; resize(); &#125;else &#123; for (e = e.next; e!=null ; e = e.next) &#123; int k = e.key; if (k == key)&#123; e.value=value; return; &#125; &#125; &#125; Entry temp = table[index].next; Entry newEntry = new Entry(key,value,temp); table[index].next = newEntry; size++; &#125; &#125; /* * 删除 * */ public void remove(int key)&#123; int index = hash(key); Entry e = table[index]; Entry pre = table[index]; if (e!=null&amp;&amp;e.next!=null)&#123; for (e = e.next;e!=null;pre = e,e=e.next)&#123; int k = e.key; if (k == e.key)&#123; pre.next = e.next; size--; return; &#125; &#125; &#125; &#125; /* * 获取 * @param key * @return * */ public int get(int key)&#123; int index = hash(key); Entry e = table[index]; if (e!=null&amp;&amp;e.next!=null)&#123; for (e = e.next;e.next!=null;e = e.next)&#123; int k = e.key; if (k == key)&#123; return e.value; &#125; &#125; &#125;// 若没有找到，则返回-1 return -1; &#125; /* * 获取散列表中元素的个数 * @return * */ public int size()&#123; return size; &#125; /* * 本身散列表不该有这个方法 在这里只是为了让我们知道它确实扩容了 * @return * */ public int getLength()&#123; return table.length; &#125; /* * 根据key 通过哈希函数获取位于散列表数组中的哪个位置 * */ private int hash(int key)&#123; return key % table.length; &#125; /* * 扩容 * */ private void resize()&#123; int newLength = table.length*2; Entry[] oldTable = table; table = new Entry[newLength]; use = 0; for (int i = 0;i&lt;oldTable.length;i++)&#123; if (oldTable[i]!=null&amp;&amp;oldTable[i].next!=null)&#123; Entry e = oldTable[i]; while (null != e.next)&#123; Entry next = e.next;// 重新计算哈希值，放入到新的地址中 int index = hash(next.key); if (table[index] == null)&#123; use++; table[index] = new Entry(-1,-1,null); &#125; Entry temp = table[index].next; Entry newEntry = new Entry(next.key,next.value,temp); table[index].next = newEntry; e = next; &#125; &#125; &#125; &#125;&#125; 1234567891011public class Entry &#123; int key; int value; Entry next; public Entry(int key, int value, Entry next) &#123; this.key = key; this.value = value; this.next = next; &#125;&#125;]]></content>
  </entry>
</search>
